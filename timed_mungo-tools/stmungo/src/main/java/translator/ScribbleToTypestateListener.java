package translator;

import genantlr.ScribbleBaseListener;
import genantlr.ScribbleParser;
import org.antlr.v4.runtime.tree.ParseTree;
import util.PrettyPrinter;

import java.io.*;
import java.util.*;

/**
 * Created by ornela on 15/02/15.
 */
public class ScribbleToTypestateListener extends ScribbleBaseListener {
    int currentState = 0;
    int currentPayload = 1;
    int currentEnum = 1;
    int localprotocolblockSize = 0;
    int currentLocalInteraction = 0;
    int totalProtocolDecl = 0;
    int currentProtocolDecl = 0;
    int labelNumbering = 1;


    String protocolAtRole = "";
    String protocolExtension = ".protocol";
    String fileExtension = ".java";
    String packageName;
    String currentProtocolName = "";
    String firstProtocolName = "";
    String generatedBy = "/**\n * Generated by StMungo\n * " + java.util.Calendar.getInstance().getTime() +
            "\n */";

    boolean firstLocalProtocol = true;
    boolean infiniteLoop;
    boolean verbose;
    boolean doPresent = false;

    List<String> enumQueue = new LinkedList<String>();
    List<String> mheadList = new LinkedList<String>();
    Map<String, Integer> recMap = new HashMap<String, Integer>();
    Map<List<String>, String> enumMap = new HashMap<List<String>, String>();
    Map<Integer, Integer> stateMap = new HashMap<Integer, Integer>();
    Map<String, Integer> doMap = new HashMap<String, Integer>();
    HashSet<String> methodSignatureSet = new HashSet<String>();
    Stack<String> recStack = new Stack<String>();

    Map<String, String> typesMap = new HashMap<String, String>();

    /**
     * the PrinterWriter typestateOut writes in the StringWriter typestateWrite
     * typestateWrite is then written in a typestateFile when the module rule is exited,
     * namely at the end of the protocol
     */
    StringWriter typestateWrite = new StringWriter();
    PrintWriter typestateOutput = new PrintWriter(typestateWrite);
    PrettyPrinter typestatePrinter = new PrettyPrinter(typestateOutput);

    /**
     * The following is in the same lines as for the typestate Write, Output and Printer
     * It is done for the role wrapper around the typestate
     */
    StringWriter roleWrite = new StringWriter();
    PrintWriter roleOutput = new PrintWriter(roleWrite);
    PrettyPrinter rolePrinter = new PrettyPrinter(roleOutput);
    /**
     * The following is in the same lines as for the typestate Write, Output and Printer
     * It is done for the main class around the typestate
     */
    StringWriter mainWrite = new StringWriter();
    PrintWriter mainOutput = new PrintWriter(mainWrite);
    PrettyPrinter mainPrinter = new PrettyPrinter(mainOutput);

    // It contains the roles participating in the protocol
    ArrayList<String> rolesAtProtocol = new ArrayList<String>();

    public ScribbleToTypestateListener(boolean verbose, String path) {
        super();
        this.verbose = verbose;
        packageName = path.replace("/", ".");
        if (packageName.endsWith("."))
            packageName = packageName.substring(0, packageName.length()-1);
    }


    int RecursiveSendReceiveInteractions(List<ScribbleParser.LocalinteractionContext> localinteractions) {
        int numberOfSendReceiveInteractions = 0;

        for (ScribbleParser.LocalinteractionContext localInteraction : localinteractions) {
            if (localInteraction.localsend() != null || localInteraction.localreceive() != null || localInteraction.localchoice() != null) {
                numberOfSendReceiveInteractions++;
            }

            if(localInteraction.localreceive()!= null && !localInteraction.localreceive().messagesignature().getPayload().isEmpty()){
                String payload = localInteraction.localreceive().messagesignature().getPayload().getChild(localInteraction.localreceive().messagesignature().getPayload().getChildCount()-2).getText();
                int aux = payload.split(",").length;
                if(aux > 1)
                    numberOfSendReceiveInteractions +=  aux - 1;
            }

            if (localInteraction.localrecursion() != null) {
                numberOfSendReceiveInteractions += RecursiveSendReceiveInteractions(localInteraction.localrecursion().localprotocolblock().localinteraction());
            }

            if (localInteraction.localchoice() != null) {
                for (int i = 0; i < localInteraction.localchoice().localprotocolblock().size(); i++) {
                    numberOfSendReceiveInteractions += RecursiveSendReceiveInteractions(localInteraction.localchoice().localprotocolblock(i).localinteraction());
                }
            }
        }
        return numberOfSendReceiveInteractions;
    }

    private void saveToFile(StringWriter fileWrite, String name, String fileExtension) {
        new File(".");
        File theDir;
        String filename = name + fileExtension;
        if(!packageName.equals("") && !packageName.equals(".")) {
            theDir = new File(packageName.replace(".", "/"));

            /* if the directory does not exist, create it */
            if (!theDir.exists()) {
                if(verbose)
                    System.out.println("creating directory: " + theDir);
                try {
                    theDir.mkdirs();
                } catch (SecurityException se) {
                    System.err.printf("Error creating the package: %s", theDir);
                }
            }
            filename = theDir + "/" + filename;
        }

        try {
            // typestateFile contains what is written in typestateWrite
            FileWriter file = new FileWriter(filename);
            file.write(fileWrite.toString());
            file.close();
        } catch (IOException e) {
            System.err.printf("Error saving typestate file: %s", e);
        }

    }

    private void createReadWriteStreams(ScribbleParser.StndLocalProtocolHeaderContext ctx, PrettyPrinter rolePrinter) {
        for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
            if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                String socketName = "socket" + ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                rolePrinter.prettyPrint("%sIn = new BufferedReader(new InputStreamReader(%s.getInputStream()));",
                        socketName, socketName);
                rolePrinter.prettyPrint("%sOut = new PrintWriter(%s.getOutputStream(), true);",
                        socketName, socketName);
            }
        }
    }

    private String capitaliseFirstLetter(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1);
    }

    /** Creating a string out of a list of role names; used in the localsend
     *   Used in local send to create the method header
     */
    private String rolenameListToString(List<ScribbleParser.RolenameContext> list) {
        StringBuilder builder = new StringBuilder();
        for (ScribbleParser.RolenameContext rolenameCtx : list) {
            builder.append(rolenameCtx.getText());
        }
        return builder.toString();
    }


    private void writeTypestateInterface() {
        StringWriter ticlassWrite = new StringWriter();
        PrintWriter ticlassOutput = new PrintWriter(ticlassWrite);
        PrettyPrinter ticlassPrinter = new PrettyPrinter(ticlassOutput);
        if(!packageName.equals("") && !packageName.equals("."))
            ticlassPrinter.prettyPrint("package %s;\n", packageName);
        ticlassPrinter.prettyPrint(generatedBy);
        ticlassPrinter.prettyPrint("public @interface Typestate{");
        ticlassPrinter.prettyPrint("String value();");
        ticlassPrinter.prettyPrint("}");

        saveToFile(ticlassWrite, "Typestate", fileExtension);

    }

    @Override
    public void enterModule(ScribbleParser.ModuleContext ctx) {
        // totalProtocolDecl stores the number of total declared local protocols in the scribble file
        // It is used when printing the state "end" in local send and local receive
        totalProtocolDecl = ctx.protocoldecl().size();
        if(ctx.protocoldecl().get(0).getChild(0) instanceof ScribbleParser.GlobalprotocoldeclContext) {
            System.out.println("StMungo must be used with local protocols.");
            System.exit(1);
        }
        String module = ctx.moduledecl().modulename().getText();
        if(packageName.equals("") && module.contains("."))
            packageName = module.substring(0, module.lastIndexOf("."));
        if(!packageName.equals("") && !packageName.equals(".")) {
            typestatePrinter.prettyPrint("package %s;\n", packageName);
            rolePrinter.prettyPrint("package %s;\n", packageName);
            mainPrinter.prettyPrint("package %s;\n", packageName);
        }
        typestatePrinter.prettyPrint(generatedBy);
        rolePrinter.prettyPrint(generatedBy);
        mainPrinter.prettyPrint(generatedBy);


        rolePrinter.prettyPrint("import java.io.IOException;");
        rolePrinter.prettyPrint("import java.io.InputStreamReader;");
        rolePrinter.prettyPrint("import java.io.PrintWriter;");
        rolePrinter.prettyPrint("import java.net.Socket;");
        rolePrinter.prettyPrint("import java.net.ServerSocket;");
        rolePrinter.prettyPrint("import java.net.UnknownHostException;");
        rolePrinter.prettyPrint("import java.io.BufferedReader;\n");



        mainPrinter.prettyPrint("import java.io.BufferedReader;");
        mainPrinter.prettyPrint("import java.io.IOException;");
        mainPrinter.prettyPrint("import java.io.InputStreamReader;\n");
    }

    @Override
    public void exitModule(ScribbleParser.ModuleContext ctx) {
        // Print the closing bracket of the typestate file
        typestatePrinter.prettyPrint("}");

        // Print the closing bracket of the role file
        rolePrinter.prettyPrint("}");

        if(doPresent && doMap.containsKey(currentProtocolName)) {
            // Print in the main file a while statement when exiting the module
            // Close do
            mainPrinter.prettyPrint("} while(true);");
            recStack.pop();
        }
        // Close the main method in the main file
        mainPrinter.prettyPrint("}");

        // Print the closing bracket of the main file
        mainPrinter.prettyPrint("}");


        /*
         * Typestate File
         */
        if(verbose){
            System.out.println("This is the typestate");
            System.out.println(typestateWrite.toString());

            System.out.println("This is the role");
            System.out.println(roleWrite.toString());

            System.out.println("This is the main");
            System.out.println(mainWrite.toString());
        }


        saveToFile(typestateWrite, protocolAtRole + "Protocol", protocolExtension);
        saveToFile(roleWrite, protocolAtRole + "Role", fileExtension);
        saveToFile(mainWrite, protocolAtRole + "Main", fileExtension);
        writeTypestateInterface();




        // For each entry in the enumMap write the choice file
        for (Map.Entry<List<String>, String> enumMapEntry : enumMap.entrySet()) {
            // Create a choice file
            StringWriter choiceWrite = new StringWriter();
            PrintWriter choiceOutput = new PrintWriter(choiceWrite);
            PrettyPrinter choicePrinter = new PrettyPrinter(choiceOutput);

            // Print in the choice file the package as a command and the enum type name
            // Print the set of labels / enums corresponding to the choice type above
            if(!packageName.equals("") && !packageName.equals("."))
                choicePrinter.prettyPrint("package %s;\n", packageName);
            choicePrinter.prettyPrint(generatedBy);
            choicePrinter.prettyPrint("enum %s {", enumMapEntry.getValue());
            choicePrinter.prettyPrint("%s;", String.join(", ", enumMapEntry.getKey()));
            choicePrinter.prettyPrint("}");

            saveToFile(choiceWrite, enumMapEntry.getValue(), fileExtension);

        }

    }

    /**
     * Translation of payloadtypedecl:
     * TYPEKW '<' IDENTIFIER '>' EXTIDENTIFIER FROMKW EXTIDENTIFIER ASKW payloadtypename ';'
     * It defines the types used as payloads in scribble
     * We translate them as comments in the typestate file, and import statements in the main and role classes
     */
    @Override
    public void exitPayloadtypedecl(ScribbleParser.PayloadtypedeclContext ctx) {
        typestatePrinter.prettyPrint("//" + String.format("type <%s> %s from %s as %s;",
                ctx.IDENTIFIER().getText(), ctx.EXTIDENTIFIER(0).getText(),
                ctx.EXTIDENTIFIER(1).getText(), ctx.payloadtypename().getText()));

        String importDecl = ctx.EXTIDENTIFIER(0).getText().replace("\"", "");
        String type = importDecl.substring(importDecl.lastIndexOf(".") + 1);

        typesMap.put(ctx.payloadtypename().getText(), type);
        mainPrinter.prettyPrint(String.format("import %s;\n", importDecl));
        rolePrinter.prettyPrint(String.format("import %s;\n", importDecl));
    }

    /** Translation of messagesignaturedecl:
     * SIGKW '<' IDENTIFIER '>' EXTIDENTIFIER FROMKW EXTIDENTIFIER ASKW simplemessagesignaturename ';'
     * It defines the signatures of the messages used in scribble
     * For now we translate them as comments in the typestate file
     */

    @Override
    public void exitMessagesignaturedecl(ScribbleParser.MessagesignaturedeclContext ctx) {
        typestatePrinter.prettyPrint("//" + String.format("sig <%s> %s from %s as %s;",
                ctx.IDENTIFIER().getText(), ctx.EXTIDENTIFIER(0).getText(), ctx.EXTIDENTIFIER(1).getText(),
                ctx.simplemessagesignaturename().IDENTIFIER().getText()));
    }

    //Old onelocalprotocolheader: LOCALKW PROTOCOLKW protocolname ATKW rolename roledecllist
    //localprotocolheader: LOCALKW PROTOCOLKW protocolname roledecl
    @Override
    public void exitStndLocalProtocolHeader(ScribbleParser.StndLocalProtocolHeaderContext ctx) {
        currentProtocolName = ctx.protocolname().getText();
        doMap.put(currentProtocolName, currentState);
        /**
         * Typestate File
         */
        // Variable firstLocalProtocol is set to true
        // This guarantees that typestate keyword is printed only once
        if (firstLocalProtocol) {
            firstProtocolName = currentProtocolName;
            // Print the keyword typesate and the role name at the beginning of the local protocol
            if (ctx.rolename() != null) {
                protocolAtRole = ctx.rolename().getText();
            } else if (ctx.protocolname().getText().contains("_"))
                protocolAtRole = ctx.protocolname().getText().split("_")[1];
            else
                for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                    if (ctx.roledecllist().roledecl(i).getText().contains("self")) {
                        /** The role name where the protocol occurs is the one corresponding to self keyword;
                         * it is used to update the global variable protocolAtRole
                         */
                        protocolAtRole = ctx.roledecllist().roledecl(i).rolename(0).getText();
                    }
                }

            typestatePrinter.prettyPrint("typestate %sProtocol {", protocolAtRole);
//        }
        // firstLocalProtocol, typestate will not be printed anymore
//        firstLocalProtocol = false;

        /*
         * Role File
         */

        // The port is used for the sockets in role and main files
        // Set it to 20000
        int port = 20000;
        int otherport = 20000;

        // For every role name in the local protocol header, different from the current role name
        // create a socketIn and socketOut for the communication
        String inSocketName;
        String outSocketName;
        String socketName;
        String serverSocketName;


        //Add in the list of roles all the role names in the protocol header
        for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
            rolesAtProtocol.add(/*ctx.protocolname().getText().split("_")[0] +*/ ctx.roledecllist().roledecl(i).rolename(0).getText());
        }

        // Index of the current role in the list of roles
        int index = rolesAtProtocol.indexOf(protocolAtRole);

        // Length of the roles list
        int length = rolesAtProtocol.size();


        // Print the class name and typestate of the current role
        rolePrinter.prettyPrint("@Typestate(\"%sProtocol\")", protocolAtRole);
        rolePrinter.prettyPrint("public class %sRole{", protocolAtRole);
        for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
            if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                inSocketName = "socket" + ctx.roledecllist().roledecl(i).rolename().get(0).getText() + "In";
                outSocketName = "socket" + ctx.roledecllist().roledecl(i).rolename().get(0).getText() + "Out";
                rolePrinter.prettyPrint("private BufferedReader %s = null;", inSocketName);
                rolePrinter.prettyPrint("private PrintWriter %s = null;", outSocketName);
            }
        }

        // Print the class constructor
        rolePrinter.prettyPrint("public %sRole() {", protocolAtRole);

        // The current role is in the first position in the list of roles
        // hence, it acts like a server to all the other roles in the protocol
        if (protocolAtRole.equals(rolesAtProtocol.get(0))) {

            // Print the server sockets if the current role acts as a server to the other roles in the protocol
            rolePrinter.prettyPrint("// Bind the sockets");
            for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                    serverSocketName = "server" + ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                    rolePrinter.prettyPrint("ServerSocket %s = null;", serverSocketName);
                }
            }

            // Print the connection to the server
            rolePrinter.prettyPrint("// Connecting to the server");
            rolePrinter.prettyPrint("try {");
            rolePrinter.prettyPrint("// Create the sockets");

            // Create the server sockets;
            // cannot merge it with the previous loop because of the try keyword, which is printed once
            for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                    serverSocketName = "server" + ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                    rolePrinter.prettyPrint("%s = new ServerSocket(%s);", serverSocketName, port++);
                }
            }
            // Close the try
            // Print the try catch if the current role acts as a client to the other roles in the protocol
            rolePrinter.prettyPrint("} catch(IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Unable to listen on ports\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}\n");
            // Connect to the clients
            rolePrinter.prettyPrint("// Accept a client connection");
            for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                    socketName = "socket" + ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                    rolePrinter.prettyPrint("Socket %s = null;", socketName);
                }
            }
            rolePrinter.prettyPrint("try {");
            for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                    rolePrinter.prettyPrint("System.out.println(\"Accepting...\");");
                    socketName = ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                    rolePrinter.prettyPrint("socket%s = server%s.accept();", socketName, socketName);
                    rolePrinter.prettyPrint("System.out.println(\"%s accepted\");", socketName);
                }
            }
            rolePrinter.prettyPrint("}");
            rolePrinter.prettyPrint("catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Accept failed\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}");

            // Create the read and write streams
            rolePrinter.prettyPrint("// Create the read and write streams");
            rolePrinter.prettyPrint("try {");
            createReadWriteStreams(ctx, rolePrinter);

            rolePrinter.prettyPrint("}");
            rolePrinter.prettyPrint("catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Read failed\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}\n");

        } else if (protocolAtRole.equals(rolesAtProtocol.get(length - 1))) {

            // The current role is in the last position in the list of roles
            // hence, it acts like a client to all the other roles in the protocol

            // Print the server sockets if the current role acts as a server to the other roles in the protocol
            rolePrinter.prettyPrint("// Connect to the other participants in the protocol");
            rolePrinter.prettyPrint("try {");
            rolePrinter.prettyPrint("// Create the sockets");
            for (int i = 0; i < ctx.roledecllist().roledecl().size(); i++) {
                if (!ctx.roledecllist().roledecl().get(i).getText().contains(protocolAtRole)) {
                    serverSocketName = "socket" + ctx.roledecllist().roledecl(i).rolename().get(0).getText();
                    rolePrinter.prettyPrint("Socket %s = new Socket(\"localhost\", %s);", serverSocketName, otherport++);
                }
            }
            createReadWriteStreams(ctx, rolePrinter);

            // Close the try
            // Print the catch-es
            rolePrinter.prettyPrint("} catch(UnknownHostException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Unable to connect to the remote host\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("} catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Input/output error\");");
            rolePrinter.prettyPrint("System.exit(-1);");

            // Close the constructor
            rolePrinter.prettyPrint("}");
        } else {

            // The current role is in a middle position, say m, in the list of roles
            // hence, it acts like a client to all the roles in postions <m
            // and acts like a server to all the roles in positins >m
            // (0 < index && index < length-1)

            // Print the server sockets if the current role acts as a server to the other roles in the protocol
            rolePrinter.prettyPrint("// Bind the sockets");

            // For all the roles in >m position than the current one
            boolean once = true;
            for (int i = index + 1; i < length; i++) {
                serverSocketName = "server" + rolesAtProtocol.get(i);
                rolePrinter.prettyPrint("ServerSocket %s = null;", serverSocketName);
                if (once) {
                    rolePrinter.prettyPrint("try {// Create the sockets");
                }
                once = false;
                rolePrinter.prettyPrint("%s = new ServerSocket(%s);", serverSocketName, port++);
            }

            // Close try
            rolePrinter.prettyPrint("}");
            rolePrinter.prettyPrint("catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Unable to listen on port\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}");

            rolePrinter.prettyPrint("// Accept a client connection");
            for (int i = index + 1; i < length; i++) {
                socketName = "socket" + rolesAtProtocol.get(i);
                rolePrinter.prettyPrint("Socket %s = null;", socketName);
            }
            rolePrinter.prettyPrint("try {");
            for (int i = index + 1; i < length; i++) {
                rolePrinter.prettyPrint("System.out.println(\"Accepting...\");");
                socketName = "socket" + rolesAtProtocol.get(i);
                serverSocketName = "server" + rolesAtProtocol.get(i);
                rolePrinter.prettyPrint("%s = %s.accept();", socketName, serverSocketName);
            }
            // Close try
            rolePrinter.prettyPrint("}\n");
            rolePrinter.prettyPrint("catch (IOException e) {\n");
            rolePrinter.prettyPrint("System.out.println(\"Accept failed\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}");

            // Read / Write
            rolePrinter.prettyPrint("// Create the read and write streams");
            rolePrinter.prettyPrint("try {");
            for (int i = index + 1; i < length; i++) {
                socketName = "socket" + rolesAtProtocol.get(i);
                rolePrinter.prettyPrint("%sIn = new BufferedReader(new InputStreamReader(%s.getInputStream()));",
                        socketName, socketName);
                rolePrinter.prettyPrint("%sOut = new PrintWriter(%s.getOutputStream(), true);",
                        socketName, socketName);
            }
            // Close try
            rolePrinter.prettyPrint("}");
            rolePrinter.prettyPrint("catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Read failed\");");
            rolePrinter.prettyPrint("System.exit(-1);");
            rolePrinter.prettyPrint("}");

            rolePrinter.prettyPrint("System.out.println(\"Accepted connection\");");

            // For all the roles in <m position than the current one
            rolePrinter.prettyPrint("// Connect to the servers");
            rolePrinter.prettyPrint("try {// Create the sockets");

            for (int i = 0; i < index; i++) {
                socketName = "socket" + rolesAtProtocol.get(i);
                // TODO: fix the port counting
                rolePrinter.prettyPrint("Socket %s = new Socket(\"localhost\", %s);", socketName, otherport++);
            }
            rolePrinter.prettyPrint("// Create the read and write streams");
            for (int i = 0; i < index; i++) {
                socketName = "socket" + rolesAtProtocol.get(i);
                rolePrinter.prettyPrint("%sIn = new BufferedReader(new InputStreamReader(%s.getInputStream()));",
                        socketName, socketName);
                rolePrinter.prettyPrint("%sOut = new PrintWriter(%s.getOutputStream(), true);",
                        socketName, socketName);
            }
            // Close try
            // Print the catch-es
            rolePrinter.prettyPrint("} catch(UnknownHostException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Unable to connect to the remote host\");");
            rolePrinter.prettyPrint("System.exit(-1);}");
            rolePrinter.prettyPrint("catch (IOException e) {");
            rolePrinter.prettyPrint("System.out.println(\"Input/output error, unable to connect\");");
            rolePrinter.prettyPrint("System.exit(-1);");

            // Close the constructor
            rolePrinter.prettyPrint("}");
        }

        // Close the role class definition
        rolePrinter.prettyPrint("}\n");

        /*
         * Main File
         */
        // Print the class definition header
        mainPrinter.prettyPrint("public class %sMain {", protocolAtRole);

        // Print the safeRead method
        mainPrinter.prettyPrint("public static String safeRead(BufferedReader reader%s) {", protocolAtRole);
        mainPrinter.prettyPrint("String readline = \"\";");
        mainPrinter.prettyPrint("try {");
        mainPrinter.prettyPrint("readline = reader%s.readLine();", protocolAtRole);
//        mainPrinter.prettyPrint("}");
        mainPrinter.prettyPrint("} catch(IOException e) {");
        mainPrinter.prettyPrint("System.out.println(\"Input/Output error, unable to read\");");
        mainPrinter.prettyPrint("System.exit(-1);");
        mainPrinter.prettyPrint("}");
        mainPrinter.prettyPrint("return readline;");
        mainPrinter.prettyPrint("}\n");

        // Print method main header
        mainPrinter.prettyPrint("public static void main(String[] args) {");

        // Create the current role
        mainPrinter.prettyPrint("// Create the current role");
        mainPrinter.prettyPrint("%sRole current%s =  new %sRole();", protocolAtRole, protocolAtRole, protocolAtRole);

        // Create the reader
        mainPrinter.prettyPrint("// reader%s can be used to input strings, and then use them in send method invocation", protocolAtRole);
        mainPrinter.prettyPrint("BufferedReader reader%s = new BufferedReader(new InputStreamReader(System.in));", protocolAtRole);

        // Print a comment before printing the methods
        mainPrinter.prettyPrint("// Method invocation follows the %s typestate", protocolAtRole);
    }
    firstLocalProtocol = false;
    }

    @Override
    public void enterStndLocalProtocolDecl(ScribbleParser.StndLocalProtocolDeclContext ctx) {
        // The number of protocol declarations, stored in currentProtocolDecl,
        // is incremented when entering a local protocol declaration
        // currentProtocolDecl is compared against totalProtocolDecl
        // when printing the state "end" in local send and local receive
        this.currentProtocolDecl++;
    }


    @Override
    public void enterLocalinteraction(ScribbleParser.LocalinteractionContext ctx) {
        // Variable currentLocalInteraction is incremented every time a localinteraction is entered
        // It is compared against localprotocolblockSize when printing the "end" state
        // in local send and local receive
        currentLocalInteraction++;

        // Variable current index contains the index of the current local interaction indexOf(ctx),
        // by inspecting the localprotocolblock, which is the parent of localinteraction
        int currentIndex = ctx.getParent().children.indexOf(ctx);

        // nextChild stores the local interaction after the current one,
        // which is at an index: currentIndex + 1
        ParseTree nextChild = ctx.getParent().getChild(currentIndex + 1);

        // Check if the next local interaction is a continue
        if (nextChild instanceof ScribbleParser.LocalinteractionContext &&
                ((ScribbleParser.LocalinteractionContext) nextChild).localcontinue() != null) {

            // Variable lcc contains the local continue statement
            // At this point we know that the next local interaction is a continue recursionlabel
            ScribbleParser.LocalcontinueContext lcc = ((ScribbleParser.LocalinteractionContext) nextChild).localcontinue();

            // Put in the stateMap an entry formed by the current state and
            // the state corresponding to the recursionlabelname found in the recMap
            // recMap is updated in enterLocalrecursion();
            stateMap.put(currentState, recMap.get(lcc.recursionlabelname().IDENTIFIER().getText()));
        }

        if (nextChild instanceof ScribbleParser.LocalinteractionContext &&
                ((ScribbleParser.LocalinteractionContext) nextChild).localdo() != null) {

            // Variable lcc contains the local continue statement
            // At this point we know that the next local interaction is a continue recursionlabel
            ScribbleParser.LocaldoContext lcc = ((ScribbleParser.LocalinteractionContext) nextChild).localdo();

            // Put in the stateMap an entry formed by the current state and
            // the state corresponding to the recursionlabelname found in the recMap
            // recMap is updated in enterLocalrecursion();
            stateMap.put(currentState, doMap.get(lcc.membername().getText()));
        }

        ParseTree currentChild = ctx.getParent().getChild(currentIndex);
        // Check if the this local interaction is a continue
        if (currentChild instanceof ScribbleParser.LocalinteractionContext &&
                ((ScribbleParser.LocalinteractionContext) currentChild).localcontinue() != null) {
            String recLabelName = ((ScribbleParser.LocalinteractionContext) currentChild).localcontinue().recursionlabelname().getText();
            mainPrinter.prettyPrint("continue _%s;", recLabelName);
        }
    }

    public String getClockconstraint(ScribbleParser.ClockconstraintContext ctx){
        // Horrible code but unaware how to add new methods to generated ANTLR classes or how to avoid this long else if chain
        String ret = "";
        if(ctx instanceof ScribbleParser.BoolContext){
            ScribbleParser.BoolContext boolCtx = (ScribbleParser.BoolContext) ctx;
            ret = boolCtx.BOOL().toString();
        } else if (ctx instanceof ScribbleParser.OrderingContext) {
            ScribbleParser.OrderingContext orderingCtx = (ScribbleParser.OrderingContext) ctx;
            ret += "(";
            ret += getClockconstraint(orderingCtx.clockconstraint());
            ret += ")";
        } else if (ctx instanceof ScribbleParser.GtContext){
            ScribbleParser.GtContext gtCtx = (ScribbleParser.GtContext) ctx;
            ret += gtCtx.clockid().IDENTIFIER().getText();
            ret += ">";
            if(gtCtx.clockconst().INT() != null){
                ret += gtCtx.clockconst().INT().toString();
            } else {
                ret += gtCtx.clockconst().FLOAT().toString();
            }
        } else if (ctx instanceof ScribbleParser.LtContext){
            ScribbleParser.LtContext ltCtx = (ScribbleParser.LtContext) ctx;
            ret += ltCtx.clockid().IDENTIFIER().getText();
            ret += "<";
            if(ltCtx.clockconst().INT() != null){
                ret += ltCtx.clockconst().INT().toString();
            } else {
                ret += ltCtx.clockconst().FLOAT().toString();
            }
        } else if (ctx instanceof ScribbleParser.EqContext){
            ScribbleParser.EqContext eqCtx = (ScribbleParser.EqContext) ctx;
            ret += eqCtx.clockid().IDENTIFIER().getText();
            ret += "=";
            if(eqCtx.clockconst().INT() != null){
                ret += eqCtx.clockconst().INT().toString();
            } else {
                ret += eqCtx.clockconst().FLOAT().toString();
            }
        } else if (ctx instanceof ScribbleParser.LteqContext){
            ScribbleParser.LteqContext lteqCtx = (ScribbleParser.LteqContext) ctx;
            ret += lteqCtx.clockid().IDENTIFIER().getText();
            ret += "<=";
            if(lteqCtx.clockconst().INT() != null){
                ret += lteqCtx.clockconst().INT().toString();
            } else {
                ret += lteqCtx.clockconst().FLOAT().toString();
            }
        } else if (ctx instanceof ScribbleParser.GteqContext){
            ScribbleParser.GteqContext gteqCtx = (ScribbleParser.GteqContext) ctx;
            ret += gteqCtx.clockid().IDENTIFIER().getText();
            ret += ">=";
            if(gteqCtx.clockconst().INT() != null){
                ret += gteqCtx.clockconst().INT().toString();
            } else {
                ret += gteqCtx.clockconst().FLOAT().toString();
            }
        } else if (ctx instanceof ScribbleParser.NotContext){
            ScribbleParser.NotContext notCtx = (ScribbleParser.NotContext) ctx; 
            ret += "!";
            ret += getClockconstraint(notCtx.clockconstraint());
        } else if (ctx instanceof ScribbleParser.AndContext){
            ScribbleParser.AndContext andCtx = (ScribbleParser.AndContext) ctx; 
            ret += getClockconstraint(andCtx.clockconstraint(0));
            ret += " & ";
            ret += getClockconstraint(andCtx.clockconstraint(1));
        } else if (ctx instanceof ScribbleParser.OrContext){
            ScribbleParser.OrContext orCtx = (ScribbleParser.OrContext) ctx; 
            ret += getClockconstraint(orCtx.clockconstraint(0));
            ret += " | ";
            ret += getClockconstraint(orCtx.clockconstraint(1));
        }
        return ret;
    }

    private String getResetpredlist(ScribbleParser.ResetpredlistContext ctx){
        String ret = ctx.clockid().IDENTIFIER().getText();
        ScribbleParser.ResetpredlistContext newCtx = ctx.resetpredlist();
        if(newCtx != null){
            ret += ",";
            ret += getResetpredlist(newCtx);
        }
        return ret;
    }
    
    private String getResetpredicate(ScribbleParser.ResetpredicateContext ctx){
        String ret = "{";
        ScribbleParser.ResetpredlistContext newCtx = ctx.resetpredlist();
        ret += getResetpredlist(newCtx);
        ret += "}";
        return ret; 
    }

    private String getTimeconstraint(ScribbleParser.TimeconstraintContext ctx){
        String ret = null;
        if(ctx != null){
            ret = "[";
            ret += getClockconstraint(ctx.constraintspec().clockconstraint());

            ScribbleParser.ResetpredicateContext rpctx = ctx.resetpredicate();
            if(rpctx != null){
                ret += ", ";
                ret += getResetpredicate(rpctx);
            }
            ret += ']';
        }
        return ret;
    }
    // Translation of localsend: messagesignature TOKW rolename (',' rolename)*
    @Override
    public void exitLocalsend(ScribbleParser.LocalsendContext ctx) {
        /*
         * Typestate File
         */

        // Print the state previous to the current method invocation
        typestatePrinter.prettyPrint("State%d = {", currentState);

        // Obtain all of the components of a local send, used later in the method header definition
        ScribbleParser.IdPayloadContext messagesignature = (ScribbleParser.IdPayloadContext) ctx.messagesignature();

        String timeconst = ""; 
        if(ctx.timeconstraint() != null)
            timeconst = getTimeconstraint(ctx.timeconstraint());
        //String messageId = messagesignature.IDENTIFIER().getText();

        // Remove the first character of a message id if it is an underscore
        String messageId = messagesignature.IDENTIFIER().getText().startsWith("_") ? messagesignature.IDENTIFIER().getText().substring(1) : messagesignature.IDENTIFIER().getText();

        // Concatenate all the rolenames where the data is sent into a string
        // It is used in the method header
        String rolenames = rolenameListToString(ctx.rolename());

        // Store in stateName the state which is the target of the method invocation
        // corresponding to local send
        String stateName = "";

        // Check if
        // this is the last protocol declared in the scribble file (currentProtocolDecl == totalProtocolDecl)
        // and the current interaction is the last one (currentLocalInteraction >= localprotocolblockSize)
        if (currentProtocolDecl == totalProtocolDecl && currentLocalInteraction >= localprotocolblockSize) {
            // The target state is the last one, hence "end"
            stateName = "end";
        } else {
            // stateName is the value of the key currentState in the state map, if it exists
            // currentState+1 otherwise
            stateName = String.format("State%d", stateMap.getOrDefault(currentState, currentState + 1));
        }

        String messagePayload = "";
        String payload = "";
        // Zero or one occurrence of the payload attached to the message
        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            // Define the method header by composing the above components
            payload = typesMap.get(messagesignature.payload().payloadelement().get(0).getText());
            messagePayload = capitaliseFirstLetter(messagesignature.payload().payloadelement().get(0).getText());
            for(int i = 1; i < messagesignature.payload().payloadelement().size(); i++) {
                messagePayload += capitaliseFirstLetter(messagesignature.payload().payloadelement().get(i).getText());
                payload += ", " + typesMap.get(messagesignature.payload().payloadelement().get(i).getText());
                }
            typestatePrinter.prettyPrint("%s void send_%s%sTo%s(%s): %s",timeconst, messageId,
                    messagePayload, rolenames, payload, stateName);

        } else {
            // Define the method header by composing the above components, without a payload
            typestatePrinter.prettyPrint("%s void send_%sTo%s(): %s", timeconst, messageId, rolenames, stateName);
        }
        // Close the current state
        typestatePrinter.prettyPrint("}\n");
        // Increment the current state for the next interaction
        currentState++;

        /*
         * Role File
         */

        // Check if the message signature has one or zero occurrences of payload attached to it
        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            payload = typesMap.get(messagesignature.payload().payloadelement().get(0).getText()) + " payload0";
            for(int i = 1; i < messagesignature.payload().payloadelement().size(); i++) {
                payload += ", " + typesMap.get(messagesignature.payload().payloadelement().get(i).getText())
                            + " payload" + i;
            }

            // Define the method signature for the role file
            String methodSignature = String.format("public void send_%s%sTo%s(%s) {",
                    messageId, messagePayload, rolenames, payload);

            // Check if the method signature is already present in the set of method definitions
            // in order to avoid duplicated definitions in the role file
            if (!methodSignatureSet.contains(methodSignature)) {
                // Add the method signature in the set of method signature
                methodSignatureSet.add(methodSignature);

                // Print in the role file the method definition, being a send
                rolePrinter.prettyPrint(methodSignature);

                for (int i = 0; i < ctx.rolename().size(); i++) {
                    for(int j = 0; j < messagesignature.payload().payloadelement().size(); j++)
                        rolePrinter.prettyPrint("this.socket%sOut.println(payload%s);", ctx.rolename().get(i).getText(), j);
                }

                // Close the method definition
                rolePrinter.prettyPrint("}\n");

                // Close the if on methodSignatureSet
            }
        } else {
            // Define the method signature for the role file
            String methodSignature = String.format("public void send_%sTo%s() {", messageId, rolenames);

            // Check if the method signature is already present in the set of method definitions
            // in order to avoid duplicated definitions in the role file
            if (!methodSignatureSet.contains(methodSignature)) {
                // Add the method signature in the set of method definitions
                methodSignatureSet.add(methodSignature);

                // Define the method by composing the above components, without a payload and without a body
                rolePrinter.prettyPrint(methodSignature);
                rolePrinter.prettyPrint("// Nothing to be sent");

                // Close the method definition
                rolePrinter.prettyPrint("}\n");

                // Close the if on methodSignatureSet
            }
        }

        /**
         * Main File
         */

        String payloadType = "";
        payload = "";
        // Zero or one occurrences of the payload attached to the message
        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            // Print send of the current payload on current role in the main file
            for(int i = 0; i < messagesignature.payload().payloadelement().size(); i++) {
                typesMap.putIfAbsent(messagesignature.payload().payloadelement().get(i).getText(), messagesignature.payload().payloadelement().get(i).getText());
                payloadType = typesMap.get(messagesignature.payload().payloadelement().get(i).getText());
                payload += "payload" + currentPayload + ", ";
                mainPrinter.prettyPrint("System.out.print(\"Send to %s: \");", rolenames);
                switch (payloadType) {
                    case "String":
                        mainPrinter.prettyPrint("%s payload%s = safeRead(reader%s);", payloadType,
                                currentPayload, protocolAtRole);
                        break;
                    case "Integer":
                        mainPrinter.prettyPrint("%s payload%s = Integer.parseInt(safeRead(reader%s));", payloadType,
                                currentPayload, protocolAtRole);
                        break;
                    default:
                        mainPrinter.prettyPrint("%s payload%s = /* parse me! */ %s.parse%s(safeRead(reader%s));",
                                payloadType, currentPayload, payloadType, payloadType, protocolAtRole);
                        break;
                }
                // Increment payload for the next round
                currentPayload++;
            }
            mainPrinter.prettyPrint("current%s.send_%s%sTo%s(%s);", protocolAtRole, messageId, messagePayload,
                    rolenames, payload.substring(0, payload.length()-2));
        } else {
            mainPrinter.prettyPrint("current%s.send_%sTo%s();", protocolAtRole, messageId, rolenames);
        }

        // Increment payload for the next round
        currentPayload++;
    }

    // Translation of localreceive: messagesignature FROMKW IDENTIFIER
    @Override
    public void exitLocalreceive(ScribbleParser.LocalreceiveContext ctx) {
        /*
         * Typestate File
         */

        // Obtain all of the components of a local send, used later in the method header definition
        ScribbleParser.IdPayloadContext messagesignature = (ScribbleParser.IdPayloadContext) ctx.messagesignature();

        // Remove the first character of a message id if it is an underscore
        String messageId = messagesignature.IDENTIFIER().getText();
        messageId = messageId.startsWith("_") ? messageId.substring(1) : messageId;

        // rolename contain the role from which the data is received
        String rolename = ctx.IDENTIFIER().getText();

        // Store in stateName the state which is the target of the method invocation
        // corresponding to local send
        String stateName = "";

        String timeconst = ""; 
        if(ctx.timeconstraint() != null)
            timeconst = getTimeconstraint(ctx.timeconstraint());

        // Check if this is the last protocol declared in the scribble file (currentProtocolDecl == totalProtocolDecl)
        // and the current interaction is the last one (currentLocalInteraction >= localprotocolblockSize)
        if (currentLocalInteraction >= localprotocolblockSize && currentProtocolDecl == totalProtocolDecl) {
            // The target state is the last one, hence "end"
            stateName = "end";
        }

        // Zero or one occurrence of the payload attached to the message
        String messagePayload = "";

        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            // Get the payload
            // Define the method header by composing the above components
            int state = stateMap.get(currentState) != null ? stateMap.get(currentState) : -1;
            for(int i = 0; i < messagesignature.payload().payloadelement().size(); i++) {
                // Print the state previous to the current method invocation
                typestatePrinter.prettyPrint("State%d = {", currentState);
                // stateName is the value of the key currentState in the state map, if it exists currentState+1 otherwise
                if(!stateName.equals("end"))
                    if(state != -1 && i == messagesignature.payload().payloadelement().size() - 1) {
                        stateMap.put(currentState, state);
                        stateName = String.format("State%d", stateMap.get(currentState));
                    }
                    else {
                        stateMap.put(currentState, currentState + 1);
                        stateName = String.format("State%d", stateMap.get(currentState));
                    }
                messagePayload = messagesignature.payload().payloadelement().get(i).getText();

                typestatePrinter.prettyPrint("%s %s receive_%s%sFrom%s(): %s",timeconst, typesMap.get(messagePayload),
                        messageId, capitaliseFirstLetter(messagePayload), rolename, stateName);
                // Increment the current state for the next interaction
                currentState++;
                typestatePrinter.prettyPrint("}\n");
            }
        } else {
            // Print the state previous to the current method invocation
            typestatePrinter.prettyPrint("State%d = {", currentState);
            stateName = stateName.equals("end") ? stateName : String.format("State%d", stateMap.getOrDefault(currentState, currentState + 1));
            // Define the method header by composing the above components, without a payload
            typestatePrinter.prettyPrint("%s void receive_%sFrom%s(): %s", timeconst, messageId, rolename, stateName);
            // Increment the current state for the next interaction
            currentState++;
            typestatePrinter.prettyPrint("}\n");
        }

        /*
         * Role File
         */

        // Print on the role file the method definition, being a receive
        // Zero or one occurrences of the payload attached to the message
        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            for(int i = 0; i < messagesignature.payload().payloadelement().size(); i++) {
                messagePayload = messagesignature.payload().payloadelement().get(i).getText();
                typesMap.putIfAbsent(messagePayload, messagePayload);
                // Define the method signature for the role file
                String methodSignature = String.format("public %s receive_%s%sFrom%s() {", typesMap.get(messagePayload),
                        messageId, capitaliseFirstLetter(messagePayload), rolename);
                if (!methodSignatureSet.contains(methodSignature)) {
                    // Add the method signature above in the set of method signatures
                    methodSignatureSet.add(methodSignature);
                    // Define the method by composing the above components
                    rolePrinter.prettyPrint(methodSignature);
                    rolePrinter.prettyPrint("String line = \"\";");
                    rolePrinter.prettyPrint("try {");
                    rolePrinter.prettyPrint("line = this.socket%sIn.readLine();", rolename);
                    rolePrinter.prettyPrint("} catch(IOException e) {");
                    rolePrinter.prettyPrint("System.out.println(\"Input/Outpur error. \" + e.getMessage());");
                    rolePrinter.prettyPrint("System.exit(-1);");
                    rolePrinter.prettyPrint("}");

                    switch (typesMap.get(messagePayload)) {
                        case "String":
                            rolePrinter.prettyPrint("return line;");
                            break;
                        case "Integer":
                            rolePrinter.prettyPrint("return Integer.parseInt(line);");
                            break;
                        default:
                            rolePrinter.prettyPrint("// Perform a cast of line to the appropriate type and then return it");
                            rolePrinter.prettyPrint("return %s.parse%s(line);", capitaliseFirstLetter(typesMap.get(messagePayload)),
                                    capitaliseFirstLetter(typesMap.get(messagePayload)));
                            break;
                    }
                    // Close the method definition
                    rolePrinter.prettyPrint("}\n");
                }
            }
        } else {
            // Define the method signature for the role file
            String methodSignature = String.format("public void receive_%sFrom%s() {", messageId, rolename);

            if (!methodSignatureSet.contains(methodSignature)) {
                // Add the method signature above in the set of method signatures
                methodSignatureSet.add(methodSignature);

                // Define the method by composing the above components, without a payload and without a body
                rolePrinter.prettyPrint(methodSignature);
                rolePrinter.prettyPrint("// Nothing to be received");

                // Close the method definition
                rolePrinter.prettyPrint("}");
            }
        }

        /*
         * Main File
         */

        // Zero or one occurrences of the payload attached to the message
        if (messagesignature.payload() != null && messagesignature.payload().payloadelement().size() > 0) {
            // Print receive of the current payload
            for(int i = 0; i < messagesignature.payload().payloadelement().size(); i++) {
                messagePayload = messagesignature.payload().payloadelement().get(i).getText();
                mainPrinter.prettyPrint("%s payload%s = current%s.receive_%s%sFrom%s();", typesMap.get(messagePayload),
                        currentPayload, protocolAtRole, messageId, capitaliseFirstLetter(messagePayload), rolename);
                mainPrinter.prettyPrint("System.out.println(\"Received from %s: \" + payload%s);", rolename,
                        currentPayload);
                // Increment payload for the next round
                currentPayload++;
            }
        } else
            mainPrinter.prettyPrint("current%s.receive_%sFrom%s();", protocolAtRole, messageId, rolename);

        // Increment payload for the next round
        currentPayload++;
    }

    // Translation of localchoice: CHOICEKW ATKW rolename localprotocolblock (ORKW localprotocolblock)*
    @Override
    public void enterLocalchoice(ScribbleParser.LocalchoiceContext ctx) {
        // Keep track of the state number of the choice block
        int choiceState = currentState;

        // Print the state opening the current method invocation
        typestatePrinter.prettyPrint("State%d = {", currentState++);

        // Set of labels / enums
        List<String> hsEnum = new LinkedList<String>();
        List<ScribbleParser.LocalprotocolblockContext> choiceBranches = ctx.localprotocolblock();
        ScribbleParser.LocalinteractionContext firstInteraction;

        // Role name where the choice is done
        String choiceAtRole = ctx.rolename().getText();

        // Stack of enums, I need it for the default case in the switch in the role file
        Stack<String> enumStack = new Stack<String>();

        // localInteractionType contains the number of a grammar rule given by the parser
        int localInteractionType;

        // If the choice is made at a protocol different from the protocolAtrRole
        if (!protocolAtRole.equalsIgnoreCase(choiceAtRole)) {
            // the first interaction after every branch of the choice is a local receive
            localInteractionType = ScribbleParser.RULE_localreceive;
        } else {
            // the first interaction after every branch of the choice is a local send
            localInteractionType = ScribbleParser.RULE_localsend;
        }

        // For each of the branches in the current choice
        // collect the labels of the choice and ultimately put them in the hash set hsEnum
        for (ScribbleParser.LocalprotocolblockContext choiceBranch : choiceBranches) {
            // Store the first interaction of every branch in variable firstInteraction
            firstInteraction = choiceBranch.localinteraction(0);
            ScribbleParser.IdPayloadContext messagesignature = null;

            // Switch on localInteracationType, previously initialized
            // and define the message signature
            switch (localInteractionType) {
                case ScribbleParser.RULE_localreceive:
                    messagesignature = (ScribbleParser.IdPayloadContext) firstInteraction.localreceive().messagesignature();
                    break;
                case ScribbleParser.RULE_localsend:
                    messagesignature = (ScribbleParser.IdPayloadContext) firstInteraction.localsend().messagesignature();
                    break;
            }
            // Add to the hash set, hsEnum, all the enum labels in upper cases,
            // obtained by the first interaction in all of the branches of the current choice
            String enumLabel = messagesignature.IDENTIFIER().getText();
            if (enumLabel.matches("^\\d+$"))
                enumLabel = "_" + enumLabel;
            else
                enumLabel = enumLabel.toUpperCase();
            hsEnum.add(enumLabel);

            // Add enums to the stack
            enumStack.add(enumLabel);
        }

        // Save the last enum pushed in the stack
        String last = enumStack.pop();

        // Before translating the local choice, we first need the name of its enum type being Choicen for some integer n
        // Choice is either an already exiting enum type name, if its enum labels are in a choice that already occurred
        // in the protocol or a freshly created enum type, if its enum labels are encountered here for the first time
        // Put in the hashmap the set of choice labels, stored in hsEnum and the name of the current choice option
        // if there is no other entry with the same key

        if (!enumMap.containsKey(hsEnum) && !protocolAtRole.equals(choiceAtRole)) {
            // currentChoice contains the name of the current choice, created here
            String currentChoice = protocolAtRole + "Choice" + currentEnum++;
            enumMap.put(hsEnum, currentChoice);
        }

        // Switch on localInteracationType, previously initialized and define the method header as a receive or a send
        // This is the method signature obtained by the choice
        // It is either a send or receive, depending which role is making the choice
        String interactionMethodSig;
        String sendToRoleNames;
        if (localInteractionType == ScribbleParser.RULE_localreceive) {
            // Define the method signature for the typestate file
            interactionMethodSig = String.format("receive_%sLabelFrom%s()", enumMap.get(hsEnum),
                    ctx.localprotocolblock(0).localinteraction(0).localreceive().IDENTIFIER().getText());
            typestatePrinter.prettyPrint("%s %s:", enumMap.get(hsEnum), interactionMethodSig);
        }

        // startState and nextState are set to the current state
        // which number is the number of the state when entering the choice + 1
        int startState = currentState;
        int nextState = currentState;

        //Print on the role file
        // Header of method definition
        String choicelabel = "stringLabel" + enumMap.get(hsEnum);

        // Switch on localInteracationType, previously set
        // and define the method header as a receive or a send
        String methodSignature;
        switch (localInteractionType) {
            case ScribbleParser.RULE_localreceive:
                // Define the method signature for the role file
                methodSignature = String.format("public %s receive_%sLabelFrom%s() {", enumMap.get(hsEnum), enumMap.get(hsEnum),
                        ctx.localprotocolblock(0).localinteraction(0).localreceive().IDENTIFIER().getText());

                // Check if the method signature is already present in the set of method signatures
                // in order to avoid duplicated definitions in the role file
                if (!methodSignatureSet.contains(methodSignature)) {
                    // Add the method signature in the set of method signature
                    methodSignatureSet.add(methodSignature);

                    // Receive label from choiceAtRole
                    // Print a try-catch on the role file
                    rolePrinter.prettyPrint(methodSignature);
                    rolePrinter.prettyPrint("String %s = \"\";", choicelabel);

                    // Try
                    rolePrinter.prettyPrint("try {");
                    rolePrinter.prettyPrint("%s = this.socket%sIn.readLine();", choicelabel, choiceAtRole);

                    // Catch
                    rolePrinter.prettyPrint("} catch(IOException e) {");
                    rolePrinter.prettyPrint("System.out.println(\"Input/Outpur error, unable to get label. \" + e.getMessage());");
                    rolePrinter.prettyPrint("System.exit(-1);");

                    // Close the catch
                    rolePrinter.prettyPrint("}");

                    // Print switch on the role file
                    rolePrinter.prettyPrint("switch(%s) {", choicelabel);

                    // Print all the cases inside the switch
                    for (ScribbleParser.LocalprotocolblockContext choiceBranch : choiceBranches) {
                        // Store the first interaction of every branch in variable firstInteraction
                        firstInteraction = choiceBranch.localinteraction(0);
                        String currentLabelName = ((ScribbleParser.IdPayloadContext) firstInteraction.localreceive().
                                messagesignature()).IDENTIFIER().getText().toUpperCase();
                        if (currentLabelName.matches("^\\d+$"))
                            currentLabelName = "_" + currentLabelName;
                        // Print the switch cases in the role file
                        if (currentLabelName.equals(last)) {
                            // Print case and default
                            rolePrinter.prettyPrint("case \"%s\":", currentLabelName);
                            rolePrinter.prettyPrint("default:");
                        } else {
                            // Print case
                            rolePrinter.prettyPrint("case \"%s\":", currentLabelName);
                        }
                        rolePrinter.prettyPrint("return %s.%s;", enumMap.get(hsEnum), currentLabelName);
                    }
                    // Close the switch in role file
                    rolePrinter.prettyPrint("}");

                    // Close the method definition in role file
                    rolePrinter.prettyPrint("}\n");

                    // Close if on methodSignatureSet
                }

                //Print switch on the main file
                mainPrinter.prettyPrint("switch(current%s.receive_%sLabelFrom%s()) {", protocolAtRole, enumMap.get(hsEnum), choiceAtRole);
                break;

            case ScribbleParser.RULE_localsend:
                // Send label to sendToRoleNames
                sendToRoleNames = rolenameListToString(ctx.localprotocolblock(0).localinteraction(0).localsend().rolename());

                for (String l : hsEnum) {
                    // Define the method signature for the role file
                    methodSignature = String.format("public void send_%sTo%s() {", l.replaceFirst("_", ""), sendToRoleNames);
                    // Check if the method signature is already present in the set of method definitions
                    // in order to avoid duplicated definitions in the role file
                    if (!methodSignatureSet.contains(methodSignature)) {
                        // Add the method signature in the set of method signature
                        methodSignatureSet.add(methodSignature);

                        // Print method signature on role file
                        rolePrinter.prettyPrint(methodSignature);
                        for (int i = 0; i < ctx.localprotocolblock(0).localinteraction(0).localsend().rolename().size(); i++) {
                            rolePrinter.prettyPrint("this.socket%sOut.println(\"%s\");", ctx.localprotocolblock(0).localinteraction(0).localsend().rolename().get(i).IDENTIFIER(), l);
                        }

                        // Close the method definition in role file
                        rolePrinter.prettyPrint("}\n");

                        // Close if on methodSignatureSet
                    }
                }

                mainPrinter.prettyPrint("System.out.print(\"Choose a label among %s: \");", hsEnum);

                //Print switch on the main file
                mainPrinter.prettyPrint("String sread%d = safeRead(reader%s);", labelNumbering, protocolAtRole);
                mainPrinter.prettyPrint("switch(sread%d){", labelNumbering);
                labelNumbering++;
                break;
        }

        // Now we have to print the target state after the method invocation,
        // which in in the case of choice, is a enum state <LABEL1: Statem, ... LABELn: Statek>
        // This is in case the choice is a branching
        // Opening the enum
        StringBuilder enumString = new StringBuilder("<");

        // The following loop has the same concept and structure as the previous one.
        // However, it cannot be merged with the former because
        // in the former we needed to create the enum labels and
        // check if a Choice with the same labels exists in the enumMap and print this
        // together with the method header stored in interactionMethodSig.
        // This has to be printed before printing the target enum state

        // For all of the branches in the current choice
        // we print every element LABELi: Statej inside the following loop
        // We use an for with index "i" instead of for each as in the previous loop
        // because we use the index when printing a comma "," between the labels
        boolean inner = false;
        boolean lastChild = false;

        if (choiceBranches.get(0).getParent().getParent().getParent().getParent() instanceof ScribbleParser.LocalchoiceContext) {
            inner = true;
        }

        if (choiceBranches.get(0).getParent().getParent().getParent().getChild(choiceBranches.get(0).getParent().getParent().getParent().getChildCount() - 2).getText().contains(choiceBranches.get(0).getText())) {
            lastChild = true;
        }


        for (int i = 0; i < choiceBranches.size(); i++) {
            // choiceBranch is the current branch in the choice
            ScribbleParser.LocalprotocolblockContext choiceBranch = choiceBranches.get(i);

            // Switch on localInteracationType, previously set
            // and define the method header as a receive or a send
            // Get the label of the first statement within the choice block
            String currentLabelName = " ";
            switch (localInteractionType) {
                case ScribbleParser.RULE_localreceive:
                    currentLabelName = ((ScribbleParser.IdPayloadContext) choiceBranch.localinteraction(0).localreceive().
                            messagesignature()).IDENTIFIER().getText().toUpperCase();
                    // Print the switch cases in the main file
                    enumQueue.add(i, String.format("%s", currentLabelName.matches("^\\d+$") ? "_" + currentLabelName : currentLabelName));
                    break;
                case ScribbleParser.RULE_localsend:
                    currentLabelName = ((ScribbleParser.IdPayloadContext) choiceBranch.localinteraction(0).localsend().
                            messagesignature()).IDENTIFIER().getText().toUpperCase();
                    sendToRoleNames = rolenameListToString(ctx.localprotocolblock(0).localinteraction(0).localsend().rolename());

                    // Print the switch cases in the main file
                    enumQueue.add(i, String.format("\"%s\"", currentLabelName.matches("^\\d+$") ? "_" + currentLabelName : currentLabelName));
                    mheadList.add(i, String.format("current%s.send_%sTo%s();", protocolAtRole, currentLabelName.replaceFirst("_", ""), sendToRoleNames));
                    break;
            }
            enumString.append(String.format("%s: State%s", currentLabelName.matches("^\\d+$") ? "_" + currentLabelName : currentLabelName, nextState));
            // If this is an internal choice
            if (protocolAtRole.equalsIgnoreCase(choiceAtRole)) {
                // It is assigned only inside Rule_localsend
                sendToRoleNames = rolenameListToString(ctx.localprotocolblock(0).localinteraction(0).localsend().rolename());
                if (i < choiceBranches.size() - 1) {
                    typestatePrinter.prettyPrint("void send_%sTo%s(): State%s,", currentLabelName.replaceFirst("_", ""), sendToRoleNames, nextState);
                } else {
                    typestatePrinter.prettyPrint("void send_%sTo%s(): State%s", currentLabelName.replaceFirst("_", ""), sendToRoleNames, nextState);
                }
            }

            // nextState is incremented by the number of send and receive local interactions inside one branch
            nextState += RecursiveSendReceiveInteractions(choiceBranch.localinteraction());

            // Print "," between the branches
            // This is where the index "i" of the for is needed
            if (i < choiceBranches.size() - 1) {
                enumString.append(", ");
            }

        }

        // At this point we know the state number when the choice ends
        // Use it to update the stateMap
        for (ScribbleParser.LocalprotocolblockContext choiceBranch : choiceBranches) {
            // As before we only want to increase the current state based on the number of send and receive interactions
            // nextState is incremented by the number of send and receive local interactions inside one branch
            currentState += RecursiveSendReceiveInteractions(choiceBranch.localinteraction());

            // Add a state entry for the last interaction within the choice branch only counting send and receive interaction
            // If the choice is followed by a continue reference in the stateMap by choiceState otherwise default to nextState
            if (inner && lastChild)
                stateMap.put(currentState - 1, stateMap.get(nextState));
            else
                stateMap.put(currentState - 1, stateMap.getOrDefault(choiceState, nextState));
        }


        // Set the currentState to the startState
        // The latter being the target state of the first branch in the choice
        // This state will be th first state in a source position right after the choice is finished
        currentState = startState;
        // Closing the enum
        enumString.append(">");
        // If this is an external choice
        if (!protocolAtRole.equalsIgnoreCase(choiceAtRole)) {
            typestatePrinter.prettyPrint(enumString.toString());
        }
        typestatePrinter.prettyPrint("}");

    }

    @Override
    public void enterLocalprotocolblock(ScribbleParser.LocalprotocolblockContext ctx) {
        // Variable localprotocolblockSize stores the number of local interactions in a local protocol
        // When exiting the module it stores the length of the localprotocolblock
        localprotocolblockSize += ctx.localinteraction().size();

        if (ctx.getParent() instanceof ScribbleParser.LocalchoiceContext) {
            mainPrinter.prettyPrint(String.format("case %s:", enumQueue.remove(0)));
            if (((ScribbleParser.LocalchoiceContext) ctx.getParent()).rolename().getText().equals(protocolAtRole)) {
                mainPrinter.prettyPrint("%s", mheadList.remove(0));
            }
        }
    }

    @Override
    public void exitLocalprotocolblock(ScribbleParser.LocalprotocolblockContext ctx) {
        List<ScribbleParser.LocalinteractionContext> localinteractions = ctx.localinteraction();
        // Check if the last localinteraction in a localprotocolblock inside a choice is not a continue
        // This means that we need to print a break statement
        // the continue l; is printed in exitLocalinteraction
        if(!localinteractions.isEmpty() && ctx.getParent() instanceof ScribbleParser.LocalchoiceContext)
            infiniteLoop = infiniteLoop && localinteractions.get(localinteractions.size() - 1).localcontinue() != null
                    || infiniteLoop && localinteractions.get(localinteractions.size() - 1).localrecursion() != null;

        if (!localinteractions.isEmpty() && localinteractions.get(localinteractions.size() - 1).localcontinue() == null
                && localinteractions.get(localinteractions.size() - 1).localdo() == null
                && ctx.getParent() instanceof ScribbleParser.LocalchoiceContext && !infiniteLoop) {
            // Check if the current localprotocolblock is inside a recursion: in that case the break is labelled
            //check if the block is a recursion
            if (recStack.size() > 0)
                mainPrinter.prettyPrint("break _%s;", recStack.peek());
            else
                mainPrinter.prettyPrint("break;");
        }
    }

    @Override
    public void exitLocalchoice(ScribbleParser.LocalchoiceContext ctx) {
        mainPrinter.prettyPrint("}");
    }


    // Translation of localrecursion: RECKW recursionlabelname localprotocolblock
    @Override
    public void enterLocalrecursion(ScribbleParser.LocalrecursionContext ctx) {
        // Put in a (global) map the recursive label/variable and the corresponding state where to jump
        String recLabelName = ctx.recursionlabelname().getText();
        recMap.put(recLabelName, currentState);
        // Put rec label in stack
        recStack.push(recLabelName);
        infiniteLoop = true;
        // Print in the main file a labelled do statement
        mainPrinter.prettyPrint("_%s: do{", recLabelName);
    }

    @Override
    public void exitLocalrecursion(ScribbleParser.LocalrecursionContext ctx) {
        // Print in the main file a while statement when exiting the recursion block
        // Close do
        mainPrinter.prettyPrint("} while(true);");
        recStack.pop();
    }

    @Override
    public void exitLocaldo(ScribbleParser.LocaldoContext ctx) {
        doPresent = true;
        String doLabel = ctx.membername().getText();
        if(doLabel.equals(currentProtocolName)) {
            recStack.push(doLabel);
            mainPrinter.prettyPrint("continue _%s;", doLabel);
            int index = mainWrite.getBuffer().lastIndexOf("typestate");
            if(doLabel.equals(firstProtocolName))
                mainWrite.getBuffer().insert(index + 9, "\n\t\t_" + doLabel + ": do{");
        }else{
            doMap.put(doLabel, currentState);
            recStack.push(doLabel);
            mainPrinter.prettyPrint("_%s: do{", doLabel);
        }
    }
}
